//
//  MessageRegistry.swift
//  Generated by automation in CLI task.
//

import Foundation

public struct MessageMetadata: Sendable {
    public let type: Message.Type
    public let name: String
    public let opCode: UInt8
    public let size: Int
    public let messageType: MessageType
    public let characteristic: CharacteristicUUID
    public let signed: Bool
    public let variableSize: Bool
    public let stream: Bool
    public let modifiesInsulinDelivery: Bool
    public let associatedType: Message.Type?  // For Request: Response type, For Response: Request type

    init?(type: Message.Type, associatedType: Message.Type? = nil) {
        let props = type.props
        if props.opCode == 0 {
            return nil
        }
        self.type = type
        self.name = String(describing: type)
        self.opCode = props.opCode
        self.size = Int(props.size)
        self.messageType = props.type
        self.characteristic = props.characteristic
        self.signed = props.signed
        self.variableSize = props.variableSize
        self.stream = props.stream
        self.modifiesInsulinDelivery = props.modifiesInsulinDelivery
        self.associatedType = associatedType
    }

    public func matches(payloadLength: Int) -> Bool {
        if stream || variableSize {
            return true
        }
        if payloadLength == size {
            return true
        }
        if signed && payloadLength == size + 24 {
            return true
        }
        if size == 0 && payloadLength == 0 {
            return true
        }
        if signed && size == 0 && payloadLength == 24 {
            return true
        }
        return false
    }
}

public enum MessageRegistry {
    // Helper to find associated type by naming convention
    private static func findAssociatedType(for type: Message.Type, in allTypes: [Message.Type]) -> Message.Type? {
        let typeName = String(describing: type)
        let simpleName = typeName.split(separator: ".").last.map(String.init) ?? typeName

        if simpleName.hasSuffix("Request") {
            // For requests, find corresponding response
            let base = simpleName.dropLast("Request".count)
            let responseName = base + "Response"
            return allTypes.first { candidate in
                let candidateName = String(describing: candidate)
                let candidateSimple = candidateName.split(separator: ".").last.map(String.init) ?? candidateName
                return candidateSimple == responseName
            }
        } else if simpleName.hasSuffix("Response") {
            // For responses, find corresponding request
            let base = simpleName.dropLast("Response".count)
            let requestName = base + "Request"
            return allTypes.first { candidate in
                let candidateName = String(describing: candidate)
                let candidateSimple = candidateName.split(separator: ".").last.map(String.init) ?? candidateName
                return candidateSimple == requestName
            }
        }

        return nil
    }

    private static let allTypes: [Message.Type] = [
        ErrorResponse.self,
        NonexistentErrorRequest.self,
        AlarmStatusRequest.self,
        AlarmStatusResponse.self,
        AlertStatusRequest.self,
        AlertStatusResponse.self,
        ApiVersionRequest.self,
        ApiVersionResponse.self,
        BasalIQAlertInfoRequest.self,
        BasalIQAlertInfoResponse.self,
        BasalIQSettingsRequest.self,
        BasalIQSettingsResponse.self,
        BasalIQStatusRequest.self,
        BasalIQStatusResponse.self,
        BasalLimitSettingsRequest.self,
        BasalLimitSettingsResponse.self,
        BolusCalcDataSnapshotRequest.self,
        BolusCalcDataSnapshotResponse.self,
        BolusPermissionChangeReasonRequest.self,
        BolusPermissionChangeReasonResponse.self,
        BolusPermissionReleaseRequest.self,
        BolusPermissionReleaseResponse.self,
        BolusPermissionRequest.self,
        BolusPermissionResponse.self,
        CGMAlertStatusRequest.self,
        CGMAlertStatusResponse.self,
        CGMGlucoseAlertSettingsRequest.self,
        CGMGlucoseAlertSettingsResponse.self,
        CGMHardwareInfoRequest.self,
        CGMHardwareInfoResponse.self,
        CGMOORAlertSettingsRequest.self,
        CGMOORAlertSettingsResponse.self,
        CGMRateAlertSettingsRequest.self,
        CGMRateAlertSettingsResponse.self,
        CGMStatusRequest.self,
        CGMStatusResponse.self,
        CancelBolusRequest.self,
        CancelBolusResponse.self,
        CentralChallengeRequest.self,
        CentralChallengeResponse.self,
        ChangeControlIQSettingsRequest.self,
        ChangeControlIQSettingsResponse.self,
        ChangeTimeDateRequest.self,
        ChangeTimeDateResponse.self,
        CommonSoftwareInfoRequest.self,
        CommonSoftwareInfoResponse.self,
        ControlIQIOBRequest.self,
        ControlIQIOBResponse.self,
        ControlIQInfoAbstractResponse.self,
        ControlIQInfoV1Request.self,
        ControlIQInfoV1Response.self,
        ControlIQInfoV2Request.self,
        ControlIQInfoV2Response.self,
        ControlIQSleepScheduleRequest.self,
        ControlIQSleepScheduleResponse.self,
        CreateIDPRequest.self,
        CreateIDPResponse.self,
        CurrentBasalStatusRequest.self,
        CurrentBasalStatusResponse.self,
        CurrentBatteryV1Request.self,
        CurrentBatteryV1Response.self,
        CurrentBatteryV2Request.self,
        CurrentBatteryV2Response.self,
        CurrentBolusStatusRequest.self,
        CurrentBolusStatusResponse.self,
        CurrentEGVGuiDataRequest.self,
        CurrentEGVGuiDataResponse.self,
        DeleteIDPRequest.self,
        DeleteIDPResponse.self,
        DetectingCartridgeStateStreamResponse.self,
        DisconnectPumpRequest.self,
        DisconnectPumpResponse.self,
        DismissNotificationRequest.self,
        DismissNotificationResponse.self,
        EnterChangeCartridgeModeRequest.self,
        EnterChangeCartridgeModeResponse.self,
        EnterChangeCartridgeModeStateStreamResponse.self,
        EnterFillTubingModeRequest.self,
        EnterFillTubingModeResponse.self,
        ExitChangeCartridgeModeRequest.self,
        ExitChangeCartridgeModeResponse.self,
        ExitFillTubingModeRequest.self,
        ExitFillTubingModeResponse.self,
        ExitFillTubingModeStateStreamResponse.self,
        ExtendedBolusStatusRequest.self,
        ExtendedBolusStatusResponse.self,
        FillCannulaRequest.self,
        FillCannulaResponse.self,
        FillCannulaStateStreamResponse.self,
        FillTubingStateStreamResponse.self,
        GetG6TransmitterHardwareInfoRequest.self,
        GetG6TransmitterHardwareInfoResponse.self,
        GetSavedG7PairingCodeRequest.self,
        GetSavedG7PairingCodeResponse.self,
        GlobalMaxBolusSettingsRequest.self,
        GlobalMaxBolusSettingsResponse.self,
        HistoryLogRequest.self,
        HistoryLogResponse.self,
        HistoryLogStatusRequest.self,
        HistoryLogStatusResponse.self,
        HistoryLogStreamResponse.self,
        HomeScreenMirrorRequest.self,
        HomeScreenMirrorResponse.self,
        IDPSegmentRequest.self,
        IDPSegmentResponse.self,
        IDPSettingsRequest.self,
        IDPSettingsResponse.self,
        InitiateBolusRequest.self,
        InitiateBolusResponse.self,
        InsulinStatusRequest.self,
        InsulinStatusResponse.self,
        Jpake1aRequest.self,
        Jpake1aResponse.self,
        Jpake1bRequest.self,
        Jpake1bResponse.self,
        Jpake2Request.self,
        Jpake2Response.self,
        Jpake3SessionKeyRequest.self,
        Jpake3SessionKeyResponse.self,
        Jpake4KeyConfirmationRequest.self,
        Jpake4KeyConfirmationResponse.self,
        LastBGRequest.self,
        LastBGResponse.self,
        LastBolusStatusRequest.self,
        LastBolusStatusResponse.self,
        LastBolusStatusV2Request.self,
        LastBolusStatusV2Response.self,
        LocalizationRequest.self,
        LocalizationResponse.self,
        MalfunctionStatusRequest.self,
        MalfunctionStatusResponse.self,
        NonControlIQIOBRequest.self,
        NonControlIQIOBResponse.self,
        NonexistentDetectingCartridgeStateStreamRequest.self,
        NonexistentEnterChangeCartridgeModeStateStreamRequest.self,
        NonexistentExitFillTubingModeStateStreamRequest.self,
        NonexistentFillCannulaStateStreamRequest.self,
        NonexistentFillTubingStateStreamRequest.self,
        NonexistentHistoryLogStreamRequest.self,
        NonexistentPumpingStateStreamRequest.self,
        OtherNotification2StatusRequest.self,
        OtherNotification2StatusResponse.self,
        OtherNotificationStatusRequest.self,
        OtherNotificationStatusResponse.self,
        PlaySoundRequest.self,
        PlaySoundResponse.self,
        ProfileStatusRequest.self,
        ProfileStatusResponse.self,
        PumpChallengeRequest.self,
        PumpChallengeResponse.self,
        PumpFeaturesAbstractResponse.self,
        PumpFeaturesV1Request.self,
        PumpFeaturesV1Response.self,
        PumpFeaturesV2Request.self,
        PumpFeaturesV2Response.self,
        PumpGlobalsRequest.self,
        PumpGlobalsResponse.self,
        PumpSettingsRequest.self,
        PumpSettingsResponse.self,
        PumpVersionRequest.self,
        PumpVersionResponse.self,
        PumpingStateStreamResponse.self,
        ReminderStatusRequest.self,
        ReminderStatusResponse.self,
        RemindersRequest.self,
        RemindersResponse.self,
        RemoteBgEntryRequest.self,
        RemoteBgEntryResponse.self,
        RemoteCarbEntryRequest.self,
        RemoteCarbEntryResponse.self,
        RenameIDPRequest.self,
        RenameIDPResponse.self,
        ResumePumpingRequest.self,
        ResumePumpingResponse.self,
        SetActiveIDPRequest.self,
        SetActiveIDPResponse.self,
        SetDexcomG7PairingCodeRequest.self,
        SetDexcomG7PairingCodeResponse.self,
        SetG6TransmitterIdRequest.self,
        SetG6TransmitterIdResponse.self,
        SetIDPSegmentRequest.self,
        SetIDPSegmentResponse.self,
        SetIDPSettingsRequest.self,
        SetIDPSettingsResponse.self,
        SetMaxBasalLimitRequest.self,
        SetMaxBasalLimitResponse.self,
        SetMaxBolusLimitRequest.self,
        SetMaxBolusLimitResponse.self,
        SetModesRequest.self,
        SetModesResponse.self,
        SetPumpAlertSnoozeRequest.self,
        SetPumpAlertSnoozeResponse.self,
        SetPumpSoundsRequest.self,
        SetPumpSoundsResponse.self,
        SetQuickBolusSettingsRequest.self,
        SetQuickBolusSettingsResponse.self,
        SetSleepScheduleRequest.self,
        SetSleepScheduleResponse.self,
        SetTempRateRequest.self,
        SetTempRateResponse.self,
        StartDexcomG6SensorSessionRequest.self,
        StartDexcomG6SensorSessionResponse.self,
        StopDexcomCGMSensorSessionRequest.self,
        StopDexcomCGMSensorSessionResponse.self,
        StopTempRateRequest.self,
        StopTempRateResponse.self,
        SuspendPumpingRequest.self,
        SuspendPumpingResponse.self,
        TempRateRequest.self,
        TempRateResponse.self,
        TimeSinceResetRequest.self,
        TimeSinceResetResponse.self,
        UnknownMobiOpcode110Request.self,
        UnknownMobiOpcode110Response.self,
        UnknownMobiOpcode20Request.self,
        UnknownMobiOpcode20Response.self,
        UnknownMobiOpcode30Request.self,
        UnknownMobiOpcode30Response.self,
        UnknownMobiOpcodeNeg124Request.self,
        UnknownMobiOpcodeNeg124Response.self,
        UnknownMobiOpcodeNeg66Request.self,
        UnknownMobiOpcodeNeg66Response.self,
        UnknownMobiOpcodeNeg70Request.self,
        UnknownMobiOpcodeNeg70Response.self,
    ]

    public static let all: [MessageMetadata] = {
        // First pass: create metadata with associations
        var metadata: [MessageMetadata] = []
        for type in allTypes {
            let associatedType = findAssociatedType(for: type, in: allTypes)
            if let meta = MessageMetadata(type: type, associatedType: associatedType) {
                metadata.append(meta)
            }
        }
        return metadata
    }()

    private static let metadataByName: [String: MessageMetadata] = {
        var dict: [String: MessageMetadata] = [:]
        for meta in all {
            dict[meta.name.lowercased()] = meta
            if let simple = meta.name.split(separator: ".").last {
                let key = String(simple).lowercased()
                dict[key] = meta
            }
        }
        return dict
    }()

    // Bidirectional lookup maps for request<->response associations
    private static let requestToResponse: [ObjectIdentifier: MessageMetadata] = {
        var dict: [ObjectIdentifier: MessageMetadata] = [:]
        for meta in all where meta.messageType == .Request {
            if let associatedType = meta.associatedType,
               let responseMeta = all.first(where: { $0.type == associatedType }) {
                dict[ObjectIdentifier(meta.type)] = responseMeta
            }
        }
        return dict
    }()

    private static let responseToRequest: [ObjectIdentifier: MessageMetadata] = {
        var dict: [ObjectIdentifier: MessageMetadata] = [:]
        for meta in all where meta.messageType == .Response {
            if let associatedType = meta.associatedType,
               let requestMeta = all.first(where: { $0.type == associatedType }) {
                dict[ObjectIdentifier(meta.type)] = requestMeta
            }
        }
        return dict
    }()

    public static func metadata(forName name: String) -> MessageMetadata? {
        metadataByName[name.lowercased()]
    }

    public static func matches(opCode: UInt8, characteristic: CharacteristicUUID? = nil) -> [MessageMetadata] {
        all.filter { meta in
            guard meta.opCode == opCode else { return false }
            if let characteristic = characteristic,
               meta.characteristic != characteristic,
               meta.type != ErrorResponse.self {
                return false
            }
            return true
        }
    }

    public static func bestMatches(opCode: UInt8, characteristic: CharacteristicUUID?, payloadLength: Int) -> [MessageMetadata] {
        var candidates = matches(opCode: opCode, characteristic: characteristic)
        let filtered = candidates.filter { $0.matches(payloadLength: payloadLength) }
        if !filtered.isEmpty {
            candidates = filtered
        }
        return candidates
    }

    public static func names() -> [String] {
        all.map { $0.name }.sorted()
    }

    // MARK: - Request/Response Association Lookups

    /// Get response metadata for a request type
    public static func responseMetadata(for requestType: Message.Type) -> MessageMetadata? {
        requestToResponse[ObjectIdentifier(requestType)]
    }

    /// Get response metadata for a request message instance
    public static func responseMetadata(for request: Message) -> MessageMetadata? {
        requestToResponse[ObjectIdentifier(type(of: request))]
    }

    /// Get request metadata for a response type
    public static func requestMetadata(for responseType: Message.Type) -> MessageMetadata? {
        responseToRequest[ObjectIdentifier(responseType)]
    }

    /// Get request metadata for a response message instance
    public static func requestMetadata(for response: Message) -> MessageMetadata? {
        responseToRequest[ObjectIdentifier(type(of: response))]
    }

    /// Get the metadata for a specific message type
    public static func metadata(for type: Message.Type) -> MessageMetadata? {
        all.first { $0.type == type }
    }

    /// Get the metadata for a specific message instance
    public static func metadata(for message: Message) -> MessageMetadata? {
        all.first { $0.type == type(of: message) }
    }

    // MARK: - Validation

    /// Validates all request-response associations and returns a list of warnings
    /// - Returns: Array of warning messages for missing or problematic associations
    public static func validateAssociations() -> [String] {
        var warnings: [String] = []

        // Check all requests for missing response associations
        let requests = all.filter { $0.messageType == .Request }
        for request in requests {
            // Skip special "Nonexistent" request types (they don't have real responses)
            if request.name.contains("Nonexistent") {
                continue
            }

            if request.associatedType == nil {
                warnings.append("Request '\(request.name)' has no associated response type")
            }
        }

        // Check all responses for missing request associations
        let responses = all.filter { $0.messageType == .Response }
        for response in responses {
            // Skip abstract responses
            if response.name.contains("Abstract") {
                continue
            }

            if response.associatedType == nil {
                warnings.append("Response '\(response.name)' has no associated request type")
            }
        }

        // Check for opcode conflicts within the same characteristic
        var opcodeMap: [String: [MessageMetadata]] = [:]
        for meta in all {
            let key = "\(meta.characteristic.rawValue):\(meta.opCode)"
            opcodeMap[key, default: []].append(meta)
        }

        for (key, metas) in opcodeMap where metas.count > 1 {
            let names = metas.map { $0.name }.joined(separator: ", ")
            warnings.append("Opcode conflict at \(key): \(names)")
        }

        return warnings
    }
}
